
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Blogs of Junyu">
    <title>LeetCode题目总结-DFS+BFS - Blogs of Junyu</title>
    <meta name="author" content="Junyu Bian">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Junyu Bian","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"articleBody":"题目116:填充每个节点的下一个右侧节点指针\n描述：\n给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\nstruct Node {  int val;  Node *left;  Node *right;  Node *next;}\n\n\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n初始状态下，所有 next 指针都被设置为 NULL。\n示例：\n输入：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1}\n输出：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1}\n提示：\n你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n思路：\n突破点：广度优先搜索。\n步骤：\n\n使用队列进行广度优先遍历；\n在接点出队列后，next指向队列首个元素，广度遍历完直接return。\n\n代码：\n123456789101112131415161718192021222324252627282930313233class Solution &#123;public:    Node* connect(Node* root) &#123;    \tif(!root) return root;    \tqueue&lt;Node*&gt; work;      work.push(root);    \twork.push(nullptr);    \tNode* cur = nullptr;    \twhile(1) &#123;        // 如果队列首部是结点        if(work.front()) &#123;        \tcur = work.front();    \t\t\twork.pop();          // 如果是非叶子结点          if(cur-&gt;left) &#123;          \twork.push(cur-&gt;left);    \t\t\t\twork.push(cur-&gt;right);          &#125;    \t\t\tcur-&gt;next = work.front();        &#125;        // 如果只剩下一个nullptr结点    \t\telse if (1 == work.size()) &#123;          return root;        &#125;        // 如果遇到nullptr结点，这是一层的分割点    \t\telse &#123;    \t\t\twork.pop();    \t\t\twork.push(nullptr);    \t\t&#125;    \t&#125;      return root;    &#125;&#125;;\n\n\n题目117:填充每个节点的下一个右侧节点指针 II\n描述：\n给定一个二叉树\nstruct Node {  int val;  Node *left;  Node *right;  Node *next;}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n初始状态下，所有 next 指针都被设置为 NULL。 \n进阶：\n你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n示例：\n输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]\n提示：\n树中的节点数小于 6000-100 &lt;= node.val &lt;= 100\n思路：\n突破点：层次遍历。\n步骤：\n\n使用队列层次遍历；\n每循环一层将这一层清空，录入孩子节点。\n\n代码：\n123456789101112131415161718192021222324252627class Solution &#123;public:    Node* connect(Node* root) &#123;        if(!root) &#123;          return root;        &#125;        queue&lt;Node*&gt; q&#123;&#123;root&#125;&#125;;        while(!q.empty()) &#123;            int n = q.size();            for(int i = 0; i &lt; n; i++)&#123;                Node* t = q.front();                q.pop();                if(n-1 != i)&#123;                    Node* tNext = q.front();                    t-&gt;next = tNext;                &#125;                if(t-&gt;left) &#123;                  q.push(t-&gt;left);                &#125;                if(t-&gt;right) &#123;                  q.push(t-&gt;right);                &#125;            &#125;        &#125;        return root;    &#125;&#125;;\n\n\n题目200:岛屿数量\n描述：\n给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。\n岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。\n此外，你可以假设该网格的四条边均被水包围。\n示例 1:\n输入:[[‘1’,’1’,’1’,’1’,’0’],[‘1’,’1’,’0’,’1’,’0’],[‘1’,’1’,’0’,’0’,’0’],[‘0’,’0’,’0’,’0’,’0’]]输出: 1示例 2:\n输入:[[‘1’,’1’,’0’,’0’,’0’],[‘1’,’1’,’0’,’0’,’0’],[‘0’,’0’,’1’,’0’,’0’],[‘0’,’0’,’0’,’1’,’1’]]输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。\n思路一：\n突破点：深度优先搜索。\n步骤：\n\n将二维网格视为无向图，相邻1之间有边相连；\n搜索到1，则标记为0；\n最终深度优先搜索次数即为岛屿数量。\n\n代码：\n12345678910111213141516171819202122232425262728293031class Solution &#123;private:    void dfs(vector&lt;vector&lt;char&gt; &gt;&amp; grid, int r, int c) &#123;        int nr = grid.size();        int nc = grid[0].size();        grid[r][c] = &#x27;0&#x27;;        if (&#x27;1&#x27; == r - 1 &gt;= 0 &amp;&amp; grid[r-1][c]) dfs(grid, r - 1, c);        if (&#x27;1&#x27; == r + 1 &lt; nr &amp;&amp; grid[r+1][c]) dfs(grid, r + 1, c);        if (&#x27;1&#x27; == c - 1 &gt;= 0 &amp;&amp; grid[r][c-1]) dfs(grid, r, c - 1);        if (&#x27;1&#x27; == c + 1 &lt; nc &amp;&amp; grid[r][c+1]) dfs(grid, r, c + 1);    &#125;public:    int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) &#123;        int nr = grid.size();        if (!nr) return 0;        int nc = grid[0].size();        int num_islands = 0;        for (int r = 0; r &lt; nr; ++r) &#123;            for (int c = 0; c &lt; nc; ++c) &#123;                if (&#x27;1&#x27; == grid[r][c]) &#123;                    ++num_islands;                    dfs(grid, r, c);                &#125;            &#125;        &#125;        return num_islands;    &#125;&#125;;\n\n思路二：\n突破点：广度优先搜索。\n步骤：\n\n将二维网格视为无向图，相邻1之间有边相连；\n搜索到1，则加入队列，并修改标记为0；\n最终广度优先搜索次数即为岛屿数量。\n\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public:    int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) &#123;        int nr = grid.size();        if (!nr) return 0;        int nc = grid[0].size();        int num_islands = 0;        for (int r = 0; r &lt; nr; ++r) &#123;            for (int c = 0; c &lt; nc; ++c) &#123;                if (grid[r][c] == &#x27;1&#x27;) &#123;                  ++num_islands;                  grid[r][c] = &#x27;0&#x27;;                  queue&lt;pair&lt;int, int&gt; &gt; neighbors;                  neighbors.push(&#123;r, c&#125;);                  while (!neighbors.front()) &#123;                    auto rc = neighbors.front();                    neighbors.pop();                    int row = rc.first, col = rc.second;                    if (0 &lt;= row - 1 &amp;&amp; &#x27;1&#x27; == grid[row-1][col]) &#123;                      neighbors.push(&#123;row-1, col&#125;);                      grid[row-1][col] = &#x27;0&#x27;;                    &#125;                    if (row + 1 &lt; nr &amp;&amp; grid[row+1][col] == &#x27;1&#x27;) &#123;                      neighbors.push(&#123;row+1, col&#125;);                      grid[row+1][col] = &#x27;0&#x27;;                    &#125;                    if (col - 1 &gt;= 0 &amp;&amp; grid[row][col-1] == &#x27;1&#x27;) &#123;                      neighbors.push(&#123;row, col-1&#125;);                      grid[row][col-1] = &#x27;0&#x27;;                    &#125;                    if (col + 1 &lt; nc &amp;&amp; grid[row][col+1] == &#x27;1&#x27;) &#123;                      neighbors.push(&#123;row, col+1&#125;);                      grid[row][col+1] = &#x27;0&#x27;;                    &#125;                  &#125;                &#125;            &#125;        &#125;        return num_islands;    &#125;&#125;;\n\n\n题目207:课程表\n描述：\n你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]\n给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？\n示例 1:\n输入: 2, [[1,0]]输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。示例 2:\n输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。\n提示：\n输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。1 &lt;= numCourses &lt;= 10^5\n思路一：\n突破点：深度优先搜索。\n步骤：\n\n题目即寻找有向图中是否成环；\n通过深度优先搜索，寻找拓扑排序；\n如果存在，说明无环，如果不存在，说明有环。\n\n代码：\n12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;private:    vector&lt;vector&lt;int&gt; &gt; edges;    vector&lt;int&gt; visited;    bool valid = true;public:    void dfs(int u) &#123;        visited[u] = 1;        for (int v: edges[u]) &#123;            if (0 == visited[v]) &#123;                dfs(v);                if (!valid) &#123;                    return;                &#125;            &#125; else if (1 == visited[v]) &#123;                valid = false;                return;            &#125;        &#125;        visited[u] = 2;    &#125;    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;        edges.resize(numCourses);        visited.resize(numCourses);        for (const auto&amp; info: prerequisites) &#123;            edges[info[1]].push_back(info[0]);        &#125;        for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) &#123;            if (!visited[i]) &#123;                dfs(i);            &#125;        &#125;        return valid;    &#125;&#125;;\n\n思路二：\n突破点：广度优先搜索。\n步骤：\n\n题目即寻找有向图中是否成环；\n通过广度优先搜索，寻找拓扑排序；\n寻找所有入度为0的点放入队列；\n每一步广度优先搜索时，取出队首节点，加入答案中；\n移除该点的所有出边；\n如果有某个相邻节点入度变为0，则将该节点加入答案；\n结束后，如果答案包含n各节点，则找到一种拓扑排序；\n否则，说明存在环。\n\n代码：\n123456789101112131415161718192021222324252627282930313233343536class Solution &#123;private:    vector&lt;vector&lt;int&gt; &gt; edges;    vector&lt;int&gt; indeg;public:    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt; &gt;&amp; prerequisites) &#123;        edges.resize(numCourses);        indeg.resize(numCourses);        for (const auto&amp; info: prerequisites) &#123;            edges[info[1]].push_back(info[0]);            ++indeg[info[0]];        &#125;        queue&lt;int&gt; q;        for (int i = 0; i &lt; numCourses; ++i) &#123;            if (0 == indeg[i]) &#123;                q.push(i);            &#125;        &#125;        int visited = 0;        while (!q.empty()) &#123;            ++visited;            int u = q.front();            q.pop();            for (int v: edges[u]) &#123;                --indeg[v];                if (0 == indeg[v]) &#123;                    q.push(v);                &#125;            &#125;        &#125;        return visited == numCourses;    &#125;&#125;;\n\n\n题目210:课程表 II\n描述：\n现在你总共有 n 门课需要选，记为 0 到 n-1。\n在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]\n给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。\n可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。\n示例 1:\n输入: 2, [[1,0]]输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。示例 2:\n输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。说明:\n输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。提示:\n这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。拓扑排序也可以通过 BFS 完成。\n思路：\n突破点：深度优先搜索。\n步骤：\n\n思考过程与题目207类似；\n当我们标记当前节点u为”搜索中“后，遍历每个相邻节点v；\n如果为未搜索，则开始搜索v，搜索完成后回溯到u；\n如果为搜索中，则找到一个环，返回false；\n如果为已完成，说明v已经在栈中，不进行操作；\nu所有相邻节点都为”已完成“后，将u入栈，并标记为已完成。\n\n代码：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;private:    // 存储有向图    vector&lt;vector&lt;int&gt; &gt; edges;    // 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成    vector&lt;int&gt; visited;    // 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶    vector&lt;int&gt; result;    // 判断有向图中是否有环    bool valid = true;public:    void dfs(int u) &#123;        // 将节点标记为「搜索中」        visited[u] = 1;        // 搜索其相邻节点        // 只要发现有环，立刻停止搜索        for (int v: edges[u]) &#123;            // 如果「未搜索」那么搜索相邻节点            if (visited[v] == 0) &#123;                dfs(v);                if (!valid) &#123;                    return;                &#125;            &#125;            // 如果「搜索中」说明找到了环            else if (visited[v] == 1) &#123;                valid = false;                return;            &#125;        &#125;        // 将节点标记为「已完成」        visited[u] = 2;        // 将节点入栈        result.push_back(u);    &#125;    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        edges.resize(numCourses);        visited.resize(numCourses);        for (const auto&amp; info: prerequisites) &#123;            edges[info[1]].push_back(info[0]);        &#125;        // 每次挑选一个「未搜索」的节点，开始进行深度优先搜索        for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) &#123;            if (!visited[i]) &#123;                dfs(i);            &#125;        &#125;        if (!valid) &#123;            return &#123;&#125;;        &#125;        // 如果没有环，那么就有拓扑排序        // 注意下标 0 为栈底，因此需要将数组反序输出        reverse(result.begin(), result.end());        return result;    &#125;&#125;;\n\n\n题目279:完全平方数\n描述：\n给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n示例 1:\n输入: n = 12输出: 3解释: 12 = 4 + 4 + 4.示例 2:\n输入: n = 13输出: 2解释: 13 = 4 + 9.\n思路一：\n突破点：广度优先搜索。\n步骤：\n\n将题目抽象为从n走到0，每次跨越平方距离，求最少跨越次数；\n使用BFS解决。\n\n代码：\n12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public:    /*返回小于n的平方序列: 1, 4, 9...*/    vector&lt;int&gt; getSquares(int n) &#123;        vector&lt;int&gt; res;        for(int i = 1; i*i &lt;= n; ++i) &#123;            res.push_back(i*i);        &#125;        return res;    &#125;      int numSquares(int n) &#123;        vector&lt;int&gt; squares = getSquares(n);        vector&lt;bool&gt; visited(n+1);    //记录已访问过的节点        queue&lt;int&gt; q;        q.push(n);        int res = 0;        visited[n] = true;        while(!q.empty()) &#123;            int size = q.size();            res++;                      while(size--) &#123;                int curr = q.front();                q.pop();                /*每次跨越的间隔为平方数*/                for(int num: squares) &#123;                    int next = curr - num;                    if(0 &gt; next) &#123;                        break;                    &#125;                    if(0 == next) &#123;                        return res;                    &#125;                    visited[next] = true;                    q.push(next);                &#125;            &#125;        &#125;        return n;    &#125;&#125;;\n\n思路二：\n突破点：动态规划。\n步骤：\n\n将题目理解为背包问题；\n背包容量v[i]表示每个完全平方数字的大小；\n背包价值w[i]为1；\n求解组成数组所需要的完全平方数数量最少即为背包的价值最低。\n\n代码：\n123456789101112131415161718192021222324252627282930class Solution &#123;public:    int numSquares(int n) &#123;        vector&lt;int&gt; choices;        int res = 1;        // 构造物品，即所有小于给定数字的完全平方数        while (n / res &gt;= res) &#123;            choices.push_back(res * res);            res++;        &#125;        const int size = choices.size();        vector&lt;int&gt; dp(n + 1, 0);        // init        for (int i = 0; i &lt;= n; ++i) &#123;            dp[i] = i;        &#125;        // 完全背包模板        for (int i = 1; i &lt; size; ++i) &#123;            for (int j = choices[i]; j &lt;= n; ++j) &#123;                dp[j] = min(dp[j], dp[j - choices[i]] + 1);            &#125;        &#125;        return dp[n];    &#125;&#125;;\n\n\n题目301:删除无效的括号\n描述：\n删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。\n说明: 输入可能包含了除 ( 和 ) 以外的字符。\n示例 1:\n输入: “()())()”输出: [“()()()”, “(())()”]示例 2:\n输入: “(a)())()”输出: [“(a)()()”, “(a())()”]示例 3:\n输入: “)(“输出: [“”]\n思路：\n突破点：深度优先遍历。\n步骤：\n\n首先遍历输入字符串，获取需要删除的左右括号个数；\n递归循环进行左右删除；\n当1.中计数都为0时，检查输入字符串是否有效。\n\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public:    bool isvalid(string s) &#123;        int cnt = 0;        for (auto c : s) &#123;            if (c == &#x27;(&#x27;) &#123;                cnt++;            &#125; else if (c == &#x27;)&#x27;) &#123;                cnt--;                if (cnt &lt; 0) return false;            &#125;        &#125;        return cnt == 0;    &#125;    void dfs(string s, int st, int l, int r, vector&lt;string&gt;&amp; ans) &#123;        if (l == 0 &amp;&amp; r == 0) &#123;            if (isvalid(s)) &#123;                ans.push_back(s);            &#125;            return;        &#125;              for (int i = st; i &lt; s.size(); i++) &#123;            if (i != st &amp;&amp; s[i] == s[i-1]) continue;            if (s[i] == &#x27;(&#x27; &amp;&amp; l &gt; 0) &#123;              \t// 删除操作，substr(a, b):从a开始个字符组成的字符串                dfs(s.substr(0, i) + s.substr(i+1, s.size()-1-i), i, l - 1, r, ans);            &#125;             if (s[i] == &#x27;)&#x27; &amp;&amp; r &gt; 0) &#123;              \t// 删除操作，substr(a, b):从a开始个字符组成的字符串                dfs(s.substr(0, i) + s.substr(i+1, s.size()-1-i), i, l, r - 1, ans);            &#125;        &#125;    &#125;    vector&lt;string&gt; removeInvalidParentheses(string s) &#123;        int left = 0;        int right = 0;        vector&lt;string&gt; ans;        for (auto c : s) &#123;            if (c == &#x27;(&#x27;) &#123;                left++;            &#125; else if (c == &#x27;)&#x27;) &#123;                if (left &gt; 0) &#123;                     left--;                &#125; else &#123;                    right++;                &#125;            &#125;        &#125;        // left和right表示左右括号要删除的个数        dfs(s, 0, left, right, ans);        return ans;    &#125;&#125;;\n\n","dateCreated":"2020-09-08T14:03:19+08:00","dateModified":"2020-09-09T12:31:18+08:00","datePublished":"2020-09-08T14:03:19+08:00","description":"题目116:填充每个节点的下一个右侧节点指针\n描述：\n给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\nstruct Node {  int val;  Node *left;  Node *right;  Node *next;}","headline":"LeetCode题目总结-DFS+BFS","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"},"publisher":{"@type":"Organization","name":"Junyu Bian","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"url":"https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/","keywords":"C++, 算法"}</script>
    <meta name="description" content="题目116:填充每个节点的下一个右侧节点指针 描述： 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node {  int val;  Node *left;  Node *right;  Node *next;}">
<meta property="og:type" content="blog">
<meta property="og:title" content="LeetCode题目总结-DFS+BFS">
<meta property="og:url" content="https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/index.html">
<meta property="og:site_name" content="Blogs of Junyu">
<meta property="og:description" content="题目116:填充每个节点的下一个右侧节点指针 描述： 给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： struct Node {  int val;  Node *left;  Node *right;  Node *next;}">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-08T06:03:19.000Z">
<meta property="article:modified_time" content="2020-09-09T04:31:18.424Z">
<meta property="article:author" content="Junyu Bian">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-wxmdysl42bg8zzt2ryhfqsfzciwu3kx9uqdpszvt5k3t8nhbngsdtxq96fkn.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Blogs of Junyu
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="http://stackoverflow.com/users"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://facebook.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://plus.google.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Google +"
                        >
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            LeetCode题目总结-DFS+BFS
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-09-08T14:03:19+08:00">
	
		    Sep 08, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/LeetCode/">LeetCode</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h3 id="题目116-填充每个节点的下一个右侧节点指针"><a href="#题目116-填充每个节点的下一个右侧节点指针" class="headerlink" title="题目116:填充每个节点的下一个右侧节点指针"></a>题目116:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></h3><hr>
<p>描述：</p>
<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}</p>
<span id="more"></span>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>示例：</p>
<p>输入：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1}</p>
<p>输出：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1}</p>
<p>提示：</p>
<p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/solution/dui-lie-mo-ni-yan-du-bian-li-shi-jian-97kong-jian-/">思路</a>：</p>
<p>突破点：<code>广度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>使用队列进行广度优先遍历；</li>
<li>在接点出队列后，next指向队列首个元素，广度遍历完直接return。</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">    	queue&lt;Node*&gt; work;</span><br><span class="line">      work.<span class="built_in">push</span>(root);</span><br><span class="line">    	work.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    	Node* cur = <span class="literal">nullptr</span>;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果队列首部是结点</span></span><br><span class="line">        <span class="keyword">if</span>(work.<span class="built_in">front</span>()) &#123;</span><br><span class="line">        	cur = work.<span class="built_in">front</span>();</span><br><span class="line">    			work.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="comment">// 如果是非叶子结点</span></span><br><span class="line">          <span class="keyword">if</span>(cur-&gt;left) &#123;</span><br><span class="line">          	work.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">    				work.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">          &#125;</span><br><span class="line">    			cur-&gt;next = work.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果只剩下一个nullptr结点</span></span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == work.<span class="built_in">size</span>()) &#123;</span><br><span class="line">          <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遇到nullptr结点，这是一层的分割点</span></span><br><span class="line">    		<span class="keyword">else</span> &#123;</span><br><span class="line">    			work.<span class="built_in">pop</span>();</span><br><span class="line">    			work.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题目117-填充每个节点的下一个右侧节点指针-II"><a href="#题目117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="题目117:填充每个节点的下一个右侧节点指针 II"></a>题目117:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">填充每个节点的下一个右侧节点指针 II</a></h3><hr>
<p>描述：</p>
<p>给定一个二叉树</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。 </p>
<p>进阶：</p>
<p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p>示例：</p>
<p>输入：root = [1,2,3,4,5,null,7]<br>输出：[1,#,2,3,#,4,5,7,#]</p>
<p>提示：</p>
<p>树中的节点数小于 6000<br>-100 &lt;= node.val &lt;= 100</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/solution/cceng-ci-bian-li-by-mrnice/">思路</a>：</p>
<p>突破点：<code>层次遍历。</code></p>
<p>步骤：</p>
<ol>
<li>使用队列层次遍历；</li>
<li>每循环一层将这一层清空，录入孩子节点。</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">          <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;Node*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                Node* t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(n<span class="number">-1</span> != i)&#123;</span><br><span class="line">                    Node* tNext = q.<span class="built_in">front</span>();</span><br><span class="line">                    t-&gt;next = tNext;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) &#123;</span><br><span class="line">                  q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) &#123;</span><br><span class="line">                  q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题目200-岛屿数量"><a href="#题目200-岛屿数量" class="headerlink" title="题目200:岛屿数量"></a>题目200:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">岛屿数量</a></h3><hr>
<p>描述：</p>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1:</p>
<p>输入:<br>[<br>[‘1’,’1’,’1’,’1’,’0’],<br>[‘1’,’1’,’0’,’1’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’0’,’0’,’0’]<br>]<br>输出: 1<br>示例 2:</p>
<p>输入:<br>[<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’1’,’0’,’0’],<br>[‘0’,’0’,’0’,’1’,’1’]<br>]<br>输出: 3<br>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/">思路一</a>：</p>
<p>突破点：<code>深度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>将二维网格视为无向图，相邻1之间有边相连；</li>
<li>搜索到1，则标记为0；</li>
<li>最终深度优先搜索次数即为岛屿数量。</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt; &gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;1&#x27;</span> == r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c]) <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;1&#x27;</span> == r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c]) <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;1&#x27;</span> == c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>]) <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;1&#x27;</span> == c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>]) <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;1&#x27;</span> == grid[r][c]) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/">思路二</a>：</p>
<p>突破点：<code>广度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>将二维网格视为无向图，相邻1之间有边相连；</li>
<li>搜索到1，则加入队列，并修改标记为0；</li>
<li>最终广度优先搜索次数即为岛屿数量。</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                  ++num_islands;</span><br><span class="line">                  grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                  queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; neighbors;</span><br><span class="line">                  neighbors.<span class="built_in">push</span>(&#123;r, c&#125;);</span><br><span class="line">                  <span class="keyword">while</span> (!neighbors.<span class="built_in">front</span>()) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> rc = neighbors.<span class="built_in">front</span>();</span><br><span class="line">                    neighbors.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">int</span> row = rc.first, col = rc.second;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= row - <span class="number">1</span> &amp;&amp; <span class="string">&#x27;1&#x27;</span> == grid[row<span class="number">-1</span>][col]) &#123;</span><br><span class="line">                      neighbors.<span class="built_in">push</span>(&#123;row<span class="number">-1</span>, col&#125;);</span><br><span class="line">                      grid[row<span class="number">-1</span>][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (row + <span class="number">1</span> &lt; nr &amp;&amp; grid[row+<span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                      neighbors.<span class="built_in">push</span>(&#123;row+<span class="number">1</span>, col&#125;);</span><br><span class="line">                      grid[row+<span class="number">1</span>][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                      neighbors.<span class="built_in">push</span>(&#123;row, col<span class="number">-1</span>&#125;);</span><br><span class="line">                      grid[row][col<span class="number">-1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (col + <span class="number">1</span> &lt; nc &amp;&amp; grid[row][col+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                      neighbors.<span class="built_in">push</span>(&#123;row, col+<span class="number">1</span>&#125;);</span><br><span class="line">                      grid[row][col+<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题目207-课程表"><a href="#题目207-课程表" class="headerlink" title="题目207:课程表"></a>题目207:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">课程表</a></h3><hr>
<p>描述：</p>
<p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<p>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。<br>示例 2:</p>
<p>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p>
<p>提示：</p>
<p>输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。<br>1 &lt;= numCourses &lt;= 10^5</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/">思路一</a>：</p>
<p>突破点：<code>深度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>题目即寻找有向图中是否成环；</li>
<li>通过深度优先搜索，寻找拓扑排序；</li>
<li>如果存在，说明无环，如果不存在，说明有环。</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; edges;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == visited[v]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == visited[v]) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/">思路二</a>：</p>
<p>突破点：<code>广度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>题目即寻找有向图中是否成环；</li>
<li>通过广度优先搜索，寻找拓扑排序；</li>
<li>寻找所有入度为0的点放入队列；</li>
<li>每一步广度优先搜索时，取出队首节点，加入答案中；</li>
<li>移除该点的所有出边；</li>
<li>如果有某个相邻节点入度变为0，则将该节点加入答案；</li>
<li>结束后，如果答案包含n各节点，则找到一种拓扑排序；</li>
<li>否则，说明存在环。</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; edges;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == indeg[i]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == indeg[v]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题目210-课程表-II"><a href="#题目210-课程表-II" class="headerlink" title="题目210:课程表 II"></a>题目210:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/">课程表 II</a></h3><hr>
<p>描述：</p>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>
<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<p>示例 1:</p>
<p>输入: 2, [[1,0]]<br>输出: [0,1]<br>解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。<br>示例 2:</p>
<p>输入: 4, [[1,0],[2,0],[3,1],[3,2]]<br>输出: [0,1,2,3] or [0,2,1,3]<br>解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。<br>因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。<br>说明:</p>
<p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。<br>提示:</p>
<p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。<br>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。<br>拓扑排序也可以通过 BFS 完成。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/">思路</a>：</p>
<p>突破点：<code>深度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>思考过程与题目207类似；</li>
<li>当我们标记当前节点u为”搜索中“后，遍历每个相邻节点v；</li>
<li>如果为未搜索，则开始搜索v，搜索完成后回溯到u；</li>
<li>如果为搜索中，则找到一个环，返回false；</li>
<li>如果为已完成，说明v已经在栈中，不进行操作；</li>
<li>u所有相邻节点都为”已完成“后，将u入栈，并标记为已完成。</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="comment">// 注意下标 0 为栈底，因此需要将数组反序输出</span></span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题目279-完全平方数"><a href="#题目279-完全平方数" class="headerlink" title="题目279:完全平方数"></a>题目279:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h3><hr>
<p>描述：</p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>示例 1:</p>
<p>输入: n = 12<br>输出: 3<br>解释: 12 = 4 + 4 + 4.<br>示例 2:</p>
<p>输入: n = 13<br>输出: 2<br>解释: 13 = 4 + 9.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/solution/dong-tai-gui-hua-bfsliang-chong-fang-fa-by-yu-mu-2/">思路一</a>：</p>
<p>突破点：<code>广度优先搜索。</code></p>
<p>步骤：</p>
<ol>
<li>将题目抽象为从n走到0，每次跨越平方距离，求最少跨越次数；</li>
<li>使用BFS解决。</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*返回小于n的平方序列: 1, 4, 9...*/</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i*i &lt;= n; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; squares = <span class="built_in">getSquares</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n+<span class="number">1</span>)</span></span>;    <span class="comment">//记录已访问过的节点</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        visited[n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            res++;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">while</span>(size--) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">/*每次跨越的间隔为平方数*/</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> num: squares) &#123;</span><br><span class="line">                    <span class="keyword">int</span> next = curr - num;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">0</span> &gt; next) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">0</span> == next) &#123;</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line">                    &#125;</span><br><span class="line">                    visited[next] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/solution/yi-ge-wan-quan-bei-bao-wen-ti-by-wtffqbpl/">思路二</a>：</p>
<p>突破点：<code>动态规划。</code></p>
<p>步骤：</p>
<ol>
<li>将题目理解为背包问题；</li>
<li>背包容量v[i]表示每个完全平方数字的大小；</li>
<li>背包价值w[i]为1；</li>
<li>求解组成数组所需要的完全平方数数量最少即为背包的价值最低。</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; choices;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造物品，即所有小于给定数字的完全平方数</span></span><br><span class="line">        <span class="keyword">while</span> (n / res &gt;= res) &#123;</span><br><span class="line">            choices.<span class="built_in">push_back</span>(res * res);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> size = choices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完全背包模板</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = choices[i]; j &lt;= n; ++j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - choices[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="题目301-删除无效的括号"><a href="#题目301-删除无效的括号" class="headerlink" title="题目301:删除无效的括号"></a>题目301:<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">删除无效的括号</a></h3><hr>
<p>描述：</p>
<p>删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。</p>
<p>说明: 输入可能包含了除 ( 和 ) 以外的字符。</p>
<p>示例 1:</p>
<p>输入: “()())()”<br>输出: [“()()()”, “(())()”]<br>示例 2:</p>
<p>输入: “(a)())()”<br>输出: [“(a)()()”, “(a())()”]<br>示例 3:</p>
<p>输入: “)(“<br>输出: [“”]</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-invalid-parentheses/solution/dfsjie-ti-by-hw_wt/">思路</a>：</p>
<p>突破点：<code>深度优先遍历。</code></p>
<p>步骤：</p>
<ol>
<li>首先遍历输入字符串，获取需要删除的左右括号个数；</li>
<li>递归循环进行左右删除；</li>
<li>当1.中计数都为0时，检查输入字符串是否有效。</li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isvalid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string s, <span class="keyword">int</span> st, <span class="keyword">int</span> l, <span class="keyword">int</span> r, vector&lt;string&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isvalid</span>(s)) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = st; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != st &amp;&amp; s[i] == s[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              	<span class="comment">// 删除操作，substr(a, b):从a开始个字符组成的字符串</span></span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, i) + s.<span class="built_in">substr</span>(i+<span class="number">1</span>, s.<span class="built_in">size</span>()<span class="number">-1</span>-i), i, l - <span class="number">1</span>, r, ans);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              	<span class="comment">// 删除操作，substr(a, b):从a开始个字符组成的字符串</span></span><br><span class="line">                <span class="built_in">dfs</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, i) + s.<span class="built_in">substr</span>(i+<span class="number">1</span>, s.<span class="built_in">size</span>()<span class="number">-1</span>-i), i, l, r - <span class="number">1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                    left--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left和right表示左右括号要删除的个数</span></span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, left, right, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/C/" rel="tag">C++</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/09/09/2020-09-09-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Heap+Stack/"
                    data-tooltip="LeetCode题目总结-Heap+Stack"
                    aria-label="PREVIOUS: LeetCode题目总结-Heap+Stack"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/09/07/2020-09-07-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Tree+BST/"
                    data-tooltip="LeetCode题目总结-Tree+BST"
                    aria-label="NEXT: LeetCode题目总结-Tree+BST"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 Junyu Bian. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/09/09/2020-09-09-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Heap+Stack/"
                    data-tooltip="LeetCode题目总结-Heap+Stack"
                    aria-label="PREVIOUS: LeetCode题目总结-Heap+Stack"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/09/07/2020-09-07-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-Tree+BST/"
                    data-tooltip="LeetCode题目总结-Tree+BST"
                    aria-label="NEXT: LeetCode题目总结-Tree+BST"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://junyu-bian.github.io/2020/09/08/2020-09-08-LeetCode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-DFS+BFS/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Junyu Bian</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-vnqkjqlintjjatuhqa130uwkuwsu27ios2j5z5qwaodowllkaooycjjcee9d.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
